# Deployment Guide: Impostor Game

## 1. Supabase Setup (Database)
Go to your Supabase Project -> **SQL Editor** and run these scripts in this exact order:

### A. Core Schema (Run this first)
```sql
-- Enable UUIDs
create extension if not exists "uuid-ossp";

-- Enums
create type room_status as enum ('LOBBY', 'PLAYING', 'VOTING', 'ENDED');
create type player_role as enum ('CIVILIAN', 'IMPOSTOR');

-- Tables
create table if not exists profiles (
  id uuid references auth.users not null primary key,
  username text unique,
  avatar_url text,
  is_admin boolean default false,
  updated_at timestamp with time zone default timezone('utc'::text, now())
);

create table if not exists word_packs (
  id bigint generated by default as identity primary key,
  category text not null,
  civilian_word text not null,
  impostor_word text,
  created_at timestamp with time zone default timezone('utc'::text, now())
);

create table if not exists rooms (
  id uuid default uuid_generate_v4() primary key,
  code text unique not null,
  host_id uuid references profiles(id) not null,
  status room_status default 'LOBBY'::room_status,
  impostor_count int default 1,
  created_at timestamp with time zone default timezone('utc'::text, now())
);

create table if not exists players (
  id uuid default uuid_generate_v4() primary key,
  room_id uuid references rooms(id) on delete cascade not null,
  user_id uuid references profiles(id) not null,
  is_alive boolean default true,
  votes_received int default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()),
  unique(room_id, user_id)
);

create table if not exists player_roles (
  player_id uuid references players(id) on delete cascade primary key,
  role player_role,
  secret_word text
);

-- RLS (Row Level Security)
alter table profiles enable row level security;
alter table rooms enable row level security;
alter table players enable row level security;
alter table player_roles enable row level security;
alter table word_packs enable row level security;

-- Policies
create policy "Public profiles" on profiles for select using (true);
create policy "Users update own profile" on profiles for update using (auth.uid() = id);
create policy "Users insert own profile" on profiles for insert with check (auth.uid() = id);

create policy "Rooms public" on rooms for select using (true);
create policy "Authenticated create rooms" on rooms for insert with check (auth.role() = 'authenticated');
create policy "Host update rooms" on rooms for update using (auth.uid() = host_id);

create policy "Players public" on players for select using (true);
create policy "Authenticated join" on players for insert with check (auth.uid() = user_id);
create policy "System update players" on players for update using (true); -- Simplified for MVP actions

create policy "Secrets private" on player_roles for select using (
  auth.uid() = (select user_id from players where id = player_roles.player_id)
);
-- Note: Insert/Update on player_roles is handled via RPC to bypass RLS for the Game Host.
```

### B. Game Functions (Run this second)
```sql
-- 1. Helper for Roles (RPC)
create or replace function assign_roles(p_roles jsonb)
returns void
language plpgsql
security definer
as $$
declare
  r record;
begin
  for r in select * from jsonb_to_recordset(p_roles) as x(player_id uuid, role player_role, secret_word text)
  loop
    insert into player_roles (player_id, role, secret_word)
    values (r.player_id, r.role, r.secret_word)
    on conflict (player_id) do update set role = r.role, secret_word = r.secret_word;
  end loop;
end;
$$;

-- 2. Win Condition Check
create or replace function check_game_over(p_room_id uuid)
returns text
language plpgsql
security definer
as $$
declare
  v_impostors_alive int;
  v_civilians_alive int;
begin
  select count(*) into v_impostors_alive
  from players p
  join player_roles pr on p.id = pr.player_id
  where p.room_id = p_room_id and p.is_alive = true and pr.role = 'IMPOSTOR';

  select count(*) into v_civilians_alive
  from players p
  join player_roles pr on p.id = pr.player_id
  where p.room_id = p_room_id and p.is_alive = true and pr.role = 'CIVILIAN';

  if v_impostors_alive = 0 then
    update rooms set status = 'ENDED' where id = p_room_id;
    return 'CIVILIANS_WIN';
  end if;

  if v_impostors_alive >= v_civilians_alive then
    update rooms set status = 'ENDED' where id = p_room_id;
    return 'IMPOSTORS_WIN';
  end if;

  return 'CONTINUE';
end;
$$;
```

---

## 2. Vercel Deployment

1.  **Push to GitHub**:
    *   Initialize git: `git init`
    *   Add files: `git add .`
    *   Commit: `git commit -m "Initial commit"`
    *   Push to your repository.

2.  **Import in Vercel**:
    *   Go to Vercel Dashboard -> Add New -> Project.
    *   Select your GitHub repository.

3.  **Environment Variables**:
    *   Add the following variables in the Vercel project settings:
        *   `NEXT_PUBLIC_SUPABASE_URL`: Your Supabase Project URL.
        *   `NEXT_PUBLIC_SUPABASE_ANON_KEY`: Your Supabase Anon Public Key.

4.  **Deploy**:
    *   Click **Deploy**.
    *   Wait for the build to finish. Assure `next.config.mjs` has `ignoreDuringBuilds: true` if you hit lint errors.

## 3. Post-Deployment Verification
*   Open the Vercel URL.
*   Sign up a user.
*   Create a room.
*   Open an Incognito window to Join the same room (simulate a 2nd player).
*   Create a 3rd user if possible (game requires 3 min).
*   Start Game and play!
