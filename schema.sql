-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- 1. Enums
create type room_status as enum ('LOBBY', 'PLAYING', 'VOTING', 'ENDED');
create type player_role as enum ('CIVILIAN', 'IMPOSTOR');

-- 2. Profiles Table (extends auth.users)
create table profiles (
  id uuid references auth.users not null primary key,
  username text unique,
  avatar_url text,
  is_admin boolean default false,
  updated_at timestamp with time zone default timezone('utc'::text, now())
);

-- 3. Word Packs Table
create table word_packs (
  id bigint generated by default as identity primary key,
  category text not null,
  civilian_word text not null,
  impostor_word text, -- Can be null/different
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- 4. Rooms Table
create table rooms (
  id uuid default uuid_generate_v4() primary key,
  code text unique not null,
  host_id uuid references profiles(id) not null,
  status room_status default 'LOBBY'::room_status,
  impostor_count int default 1,
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- 5. Players Table
create table players (
  id uuid default uuid_generate_v4() primary key,
  room_id uuid references rooms(id) on delete cascade not null,
  user_id uuid references profiles(id) not null,
  role player_role, -- Null until game starts
  secret_word text,
  is_alive boolean default true,
  votes_received int default 0,
  joined_at timestamp with time zone default timezone('utc'::text, now()),
  unique(room_id, user_id)
);

-- Enable RLS
alter table profiles enable row level security;
alter table word_packs enable row level security;
alter table rooms enable row level security;
alter table players enable row level security;

-- Policies

-- Profiles: Public read, User update own
create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can update own profile."
  on profiles for update
  using ( auth.uid() = id );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

-- Word Packs: Read only / Admin write
create policy "Word packs are viewable by everyone."
  on word_packs for select
  using ( true );

create policy "Only admins can insert/update/delete word packs."
  on word_packs for all
  using ( exists ( select 1 from profiles where id = auth.uid() and is_admin = true ) );

-- Rooms: Viewable by everyone (or anyone with the code)
create policy "Rooms are viewable by everyone."
  on rooms for select
  using ( true );

create policy "Authenticated users can create rooms."
  on rooms for insert
  with check ( auth.role() = 'authenticated' );

create policy "Host can update room status."
  on rooms for update
  using ( auth.uid() = host_id );

-- Players:
-- 1. View Basic Info (Who is in the room, alive status, votes)
-- We separate sensitive columns in a view or handling it via column-level security if Postgres supported it easily for specific roles,
-- but Supabase RLS is row-based.
-- Wait, the USER requirement relies on never querying `role` or `secret_word`.
-- Standard RLS applies to the whole row. If we select *, we get everything if the policy passes.
-- To achieve field-level security via RLS, we can't easily do it in one table without complex hacks or multiple policies (which are OR'd).
-- The User requirement: "A player must NEVER be able to query the role or secret_word of another player via the API until the game is over."
-- This implies we need conditional logic on SELECT.
-- Postgres doesn't strictly support Column Level Security with separate policies for columns in the same way RLS does rows.
-- HOWEVER, we can achieve this by ensuring the query simply returns NULL or the rows are filtered?
-- No, if the row is visible, all columns are visible.
-- BEST PRACTICE: Split `players` into `public_player_info` and `private_player_info` OR use a View/Function.
-- BUT user asked for specific tables.
-- A common workaround in Supabase/Postgres is:
-- The straightforward RLS policy allows seeing the row.
-- To hide data, the client must NOT request it, but a malicious client could.
-- TO fix this properly:
-- OPTION A: Add a check `using (auth.uid() = user_id OR room_status = 'ENDED')`. This would mean you can't see OTHER players at all during the game?
-- That breaks the game (you need to see who is in the room to vote for them).
-- So you must be able to see "Player X exists" but NOT "Player X is Impostor".
-- This requires separating the data or using a PostgreSQL View for the API.

-- Let's Refine the Schema for security as per instruction "A user can only select role from players IF...".
-- Since Supabase exposes tables directly, we should split the instruction.
-- We will Create a `players` table with public info, and `player_secrets` table with private info?
-- OR we keep one table and rely on a VIEW for the UI, but deny access to the raw table?
-- Actually, the provided schema request lists distinct columns impacting security in `players`.
-- I will propose a SECURE VIEW approach or a separate secrets table.
-- Given the constraints: "Tables: ... players: ... role, secret_word ...", the user *wants* them in one table.
-- I can use Postgres `CASE` in a View, or just be strict.
-- IF I use strict RLS on the table `players`:
-- Policy: "Enable read" `using (true)` -> Allows `select *`. Malicious user gets roles.
-- This violates the invalidation rule.

-- ALTERNATIVE: Use Supabase Auth User Metadata? No, that's not relational.
-- ALTERNATIVE: Use a `player_roles` table.
-- Tables:
-- `players` (public): id, room_id, user_id, is_alive, votes_received.
-- `player_secrets` (private): player_id, role, secret_word.
-- This is the cleanest way to enforce "You cannot see this column".

-- However, the user provided a SPECIFIC schema in section 2.
-- "Tables: ... players ... role ... secret_word".
-- I must follow the schema but implement "Security (Row Level Security)".
-- "Policy Rule: A user can only select role from players IF auth.uid() == user_id OR rooms.status == 'ENDED'."
-- This specific wording sounds like they might be thinking of a conceptual rule.
-- In standard Postgres RLS, you cannot hide specific columns for a row that is otherwise visible.
-- I will add a comment explaining this and implementation:
-- I will create a VIEW `public_players` that excludes sensitive data.
-- And I will lock down `players` table so you can only query your OWN row (or all rows if game ended).
-- BUT if I lock down `players` to "own row only", how do I render the list of Avatars in the lobby?
-- I can't.
-- So I MUST split the table or use a View.
-- Given the "Senior Architect" persona, I should solve this definitively.
-- I will modify the schema slightly to be secure OR use a PostgreSQL View associated with the table idea.
-- Actually, standard practice with Supabase when strict column security is needed is ensuring the client only selects what they need, but that's not "Anti-Cheat".
-- I will stick to the User's table definitions but adds a `players_public` VIEW and revoke public access to the raw `players` table for SELECT (except for own row).
-- Wait, Supabase client needs to select from `players`.
-- I will split the data into `players` (game state) and `player_roles` (secrets) to be perfectly secure while matching the intent.
-- Or better, I will follow the user's schema perfectly but add a VIEW called `game_players` (or similar) helping the frontend,
-- AND RLS on `players` that says:
-- `using (auth.uid() = user_id OR EXISTS (SELECT 1 FROM rooms WHERE id = players.room_id AND status = 'ENDED'))`
-- This policy effectively HIDES the row from you if you are not the owner or game not ended.
-- BUT we need to see the players in the lobby!
-- Lobby status: 'LOBBY'. If status is LOBBY, maybe secrets are null anyway? Yes.
-- But once 'PLAYING', secrets are populated.
-- If I hide the row, the player disappears from the screen.
-- CONCLUSION: To satisfy "See the player" but "Not the role", and keep 1 table, is impossible with standard RLS alone.
-- I will implement the VIEW approach as the "Architect" solution.
-- User asked: "Tables: ... 4. players ...".
-- I will keep the table `players` as the source of truth.
-- I will create a View `public_players` which exposes filtered data.
-- I will revoke direct SELECT on `players` for anon/authenticated roles unless they use the View? Use RLS to enforce logic.
-- Actually, Postgres DOES support column-level privileges (GRANT SELECT (col1, col2) ON players TO authenticated).
-- THIS is the solution!
-- I can Grant SELECT on specific columns to the `authenticated` role.
-- But RLS is dynamic (Game Ended vs Playing). Column grants are static.
-- So Column Grants don't work for "Game Ended".

-- Let's go with the separate table approach for secrets being the most robust, but it deviates from the user's table list which they might be attached to.
-- Re-reading strict instruction: "Policy Rule: A user can only select role from players IF auth.uid() == user_id OR rooms.status == 'ENDED'."
-- Implementing this literally in an RLS check `USING` clause hides the whole row.
-- If I hide the whole row, I can't see who is alive to vote for them unless I duplicate that data.
-- So either 1) Data duplication (public vs private table) OR 2) The user accepts that standard RLS hides the player presence if we enforce privacy.
-- But the User wants "List all is_alive players".
-- Okay, I will implement the "Split Pattern" effectively but keep the naming close to what they want.
-- I will create `players` table as requested.
-- I will creating a Function `get_room_players(room_id)` that returns the sanitized JSON?
-- Or I will just split `player_secrets` (role, secret_word) from `players` (public info).
-- I'll stick to the Users schema as "Logical" schema but implement it physically as:
-- Table `players`: id, room_id, user_id, is_alive, votes_received.
-- Table `player_secrets`: id (ref players), role, secret_word.
-- And a View `players_view` that joins them securely?
-- No, if I write the SQL script, user might be confused if I change table names.
-- I will execute the schema AS REQUESTED, but likely use a Postgres Function for fetching players securely if strictness is required,
-- OR I will assume that for this MVP, we might rely on "Row Level Security" hiding rows and maybe use a separate "presences" tracker?
-- No, user said "Lobby State: Uses Supabase Realtime to show a list of players".
-- Realtime listens to `players`.
-- If RLS hides the row, Realtime won't send it?
-- Correct.
-- So if I hide the row of *other* players to protect their `role`, I can't see them in the lobby.
-- BUT in the Lobby, `role` is NULL. So I can allow seeing rows when `role` is NULL.
-- Once game starts, `role` is set. If I then hide the row, they disappear.
-- ERROR in User's Logic vs Supabase RLS capabilities.
-- SOLUTION:
-- I will create the table `players` with ALL fields.
-- I will create a RLS policy that allows viewing ALL rows in the Room. (So you can see names/avatars/alive status).
-- I will create a Postgres Trigger or Generated Column? No.
-- The ONLY way to protect `role` column in a single table while allowing `select *` is... you can't.
-- YOU MUST separate the data.
-- I will assume the role of "Senior Architect" and make the executive decision to Split the tables for security, explaining why.
-- "To meet the strict Anti-Cheat requirement while maintaining Realtime visibility of players, I have separated sensitive data into a `player_roles` table."
-- This is the professional way.

-- REVISED SCHEMA PLAN:
-- 1. `profiles`
-- 2. `word_packs`
-- 3. `rooms`
-- 4. `players` (Public info: id, room_id, user_id, is_alive, votes_received)
-- 5. `player_secrets` (Private info: player_id, role, secret_word)
-- I will write the SQL to reflect this.

-- Wait, let me look at the User Request again.
-- "Tables: 4. players ... role, secret_word ..."
-- "Security ... A player must NEVER be able to query the role ... Policy Rule: A user can only select role from players IF ..."
-- The user is describing a desired outcome, not realizing the implementation constraint.
-- I will implement the Split Table strategy.

create table players (
  id uuid default uuid_generate_v4() primary key,
  room_id uuid references rooms(id) on delete cascade not null,
  user_id uuid references profiles(id) not null,
  is_alive boolean default true,
  votes_received int default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()),
  unique(room_id, user_id)
);

create table player_roles (
  player_id uuid references players(id) on delete cascade primary key,
  role player_role,
  secret_word text
);

-- Policies under this model:
-- `players`: SELECT using (true) -- Everyone can see everyone (in the lobby/game).
-- `player_roles`: SELECT using ( auth.uid() = (select user_id from players where id = player_id) OR (select status from rooms join players on players.room_id = rooms.id where players.id = player_id) = 'ENDED' )

-- This is secure and robust. I will write this into schema.sql.
-- I need to make sure I update my implementation plan to reflect this deviation/refinement.

